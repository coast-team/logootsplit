package crdt;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import crdt.SequenceOperation.OpType;

/**
 * Squeleton of mergeAlgorithm
 *
 * @author urso
 */
public abstract class MergeAlgorithm extends CRDT<String> implements Serializable {

    private final Document doc;
    
    /**
     *
     * @param doc Document of this merge algorithm
     * @param siteId SiteID or replicat number
     */
    public MergeAlgorithm(Document doc, int siteId) {
        super(siteId);
        this.doc = doc;
        this.setReplicaNumber(siteId);
    }

    /**
     * Integrate remote message from another replicas 
     * To be define by the concrete merge algorithm
     *
     * @param message from another replicas
     * @throws IncorrectTraceException
     */
    protected abstract void integrateRemote(Operation message) throws IncorrectTraceException;

    /**
     *
     * @return the document
     */
    public Document getDoc() {
        return doc;
    }

    /**
     * Old school function need to be refactored in directly CRDT Message
     *
     * @param opt Sequence Operation
     * @return List of message for sequence
     * @throws IncorrectTraceException
     */
    private List<? extends Operation> oldApplyLocal(SequenceOperation opt) throws IncorrectTraceException {
        switch (opt.getType()) {
            case insert:
                return localInsert(opt);
            case delete:
                return localDelete(opt);
            case replace:
                return localReplace(opt);
            case update:
                return localUpdate(opt);
            case move:
                return localMove(opt);
            case noop:
                return null;
            default:
                return null;
            //throw new IncorrectTraceException("Unsupported operation : " + opt);
        }
    }

    /**
     * Integrate local modification of the document. This function to stay
     * compatible with causal dispatcher localmodification is performed and a
     * sequence message is transformed to CRDTMessage.
     *
     * @param op local operation
     * @return CRDT message will be sent to another
     * @throws PreconditionException
     */
    @Override
    public CRDTMessage applyLocal(LocalOperation op) throws Exception {
        if (!(op instanceof SequenceOperation)) {
            throw new Exception("Not a sequenceOperation : " + op);
        }

        List<? extends Operation> l = oldApplyLocal((SequenceOperation) op);
        if (l == null || l.isEmpty()) {
            return CRDTMessage.emptyMessage;
        }

        CRDTMessage m = null;
        for (Operation n : l) {
            if (m == null) {
                m = new OperationBasedOneMessage(n);
            } else {
                m = m.concat(new OperationBasedOneMessage(n));
            }
        }

        return m;
    }

    public final CRDTMessage insert(int position, String content) throws Exception {
        return applyLocal(SequenceOperation.insert(position, content));
    }

    public final CRDTMessage remove(int position, int length) throws Exception {
        return applyLocal(SequenceOperation.delete(position, length));
    }

    /**
     * integrate remote operations.
     *
     * @param msg message generated by another replicas
     */
    /*@Override
     public void applyRemote(CRDTMessage msg) {
     ((CommutativeMessage)msg).execute(this);
        
     if (DEBUG) states.add(doc.view());
     }*/
    @Override
    public void applyOneRemote(CRDTMessage message) {
        try {
            integrateRemote(CRDTMessage2SequenceMessage(message));
        } catch (IncorrectTraceException ex) {
            throw new IllegalStateException(ex);
        }
    }

    public static Operation CRDTMessage2SequenceMessage(CRDTMessage message) {
        return (Operation) ((OperationBasedOneMessage) message).getOperation();
    }

    /**
     * return document
     *
     * @return
     */
    @Override
    public String lookup() {
        return doc.view();
    }

    /**
     * The defaut behavior of localInsert and localDelete is to call
     * generateLocal. Either localXXXs or generateLocal should be overrriden.
     *
     * @param opt local modification
     * @return Messages generated by replication algorithm will sent to another
     * replicas
     * @throws IncorrectTraceException by default
     */
    protected abstract  List<? extends Operation> localInsert(SequenceOperation opt) throws IncorrectTraceException;

    protected abstract List<? extends Operation> localDelete(SequenceOperation opt) throws IncorrectTraceException;

    /**
     * Default behavior of update is to delete then insert
     */
    protected List<? extends Operation> localUpdate(SequenceOperation opt) throws IncorrectTraceException {
        return localReplace(opt);
    }

    /**
     * Default behavior of move is to delele then insert
     */
    protected List<? extends Operation> localMove(SequenceOperation opt) throws IncorrectTraceException {
        SequenceOperation del = new SequenceOperation(OpType.delete, opt.getPosition(), opt.getContent().size(), null);
        SequenceOperation ins = new SequenceOperation(OpType.insert, opt.getDestination(), 0, opt.getContent());
        List lop = localDelete(del);
        lop.addAll(localInsert(ins));
        return lop;
    }

    /**
     * Default behavior of replace is to delete then insert
     */
    protected List<? extends Operation> localReplace(SequenceOperation opt) throws IncorrectTraceException {
        List lop = localDelete(opt);
        lop.addAll(localInsert(opt));
        return lop;

    }

}
